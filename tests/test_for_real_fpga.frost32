.org 0x0000
main:
{
	; Assume top of available memory is here.
	cpyi sp, 0x7fff

	cpyi u1, 0

	; Set the interrupt handler
	cpyi u0, interrupt_handler
	cpy idsta, u0

	;sub u7, u7

	cpy u7, zero
	cpyi u0, var
	str zero, [u0, zero]

	; Just so we don't have to change this register later
	cpyi u2, code_to_modify

	; I really need a pseudo instruction for non-indexed loads and stores.
	; That will probably be coming....
	cpyi u3, data_for_subtract_from_u1
	ldr u3, [u3, zero]
	cpyi u4, data_for_add_to_u1
	ldr u4, [u4, zero]

	; For calling the subroutine
	cpyi u5, change_var




	ei
	bra wait_for_interrupt

}



interrupt_handler:
{
	; Switch to an addi
	str u4, [u2, zero]

	; Change the variable
	call u5

	; Switch back to a subi
	str u3, [u2, zero]

	reti
}


wait_for_interrupt:
{
	; The high 8 bits of u7 are shown on the LEDs of my FPGA 
	call u5
	bra wait_for_interrupt
}

change_var:
	subi sp, 8
	stri u0, [sp, 4]
	stri u1, [sp, 8]

	cpyi u0, var
	ldr u1, [u0, zero]

code_to_modify:
	;dec u1
	subi u1, 20
	;add zero, zero, zero

	cpy u7, u1

	str u1, [u0, zero]

	ldri u0, [sp, 4]
	ldri u1, [sp, 8]
	addi sp, 8
	jmp lr


;data_for_dec_u1:
data_for_subtract_from_u1:
{
	;dec u1
	subi u1, 20
	;dec u1
}

data_for_add_to_u1:
{
	addi u1, 20
	;muli u1, u5, 20
}

var:
	.space 4

.org 0x4000
quit:
{
	bra quit
}

;.org 0x6000 


;.org 0x9000
;; Write to this address to trigger the interrupt
;trigger_an_interrupt:
